<:Head>
	<title>Source Definition</title>
</:Head>

<Layout page='source'>
  <div class="alert alert-info" role="alert">
    Set the type of source record, and configure it. This is how Link will access your Historian server.
		<a href="" class="badge badge-pill badge-info" on:click='saveAndNext()'>Save &gt;</a>
  </div>

<!-- SOURCE SELECT -->
<div id="series-select">
    <div class="form-group pull-left">
			<nav class="nav nav-pills nav-justified">
				{{#each Object.keys(sourceTypes) as type}}
  			<a class="nav-link {{config.source._class == type ? 'active' : ''}}" href="" on:click='set({sourceType:type})'>{{rtxTypes[type]}}</a>
				{{/each}}
			</nav>
    </div>

    <form role="form" class='form-horizontal'>

        <table class="table">
            <tbody>
              {{#each inputRows as row}}
              <tr>
                <th scope="row">{{row.text}}</th>
                {{#if row.inputType == "text-line"}}
                <td>
                  <input type="text" class="form-control" bind:value='config.source[row.key]' data-toggle="tooltip" data-placement="top" title="{{row.helptext}}" />
                </td>
                {{/if}}
                <td>
                  {{#if row.inputType == "select-driver"}}
                  <select class="form-control" bind:value='config.source[row.key]' data-toggle="tooltip" data-placement="top" title="{{row.helptext}}">
                    {{#each drivers as driver}}
                    <option value="{{driver}}">{{driver}}</option>
                    {{/each}}
                  </select>
                  {{/if}}
                  {{#if row.inputType == "select-zone"}}
                  <select class="form-control" bind:value='config.source[row.key]' data-toggle="tooltip" data-placement="top" title="{{row.helptext}}">
                    {{#each row.options as option}}
                    <option value="{{option}}">{{option}}</option>
                    {{/each}}
                  </select>
                  {{/if}}
                  {{#if row.inputType == "text-area"}}
                  <textarea class="form-control" rows="3" placeholder="{{row.placeholder}}" bind:value='config.source[row.key]' data-toggle="tooltip" data-placement="top" title="{{row.helptext}}">
                  </textarea>
                  {{/if}}
                </td>
              </tr>
              {{/each}}
            </tbody>
        </table>

        <div class="input-group" ng-if="config.source._class != 'none'">
            <button type="submit" class="btn btn-default" on:click='connect(event)'>Connect</button>
        </div>
    </form>

<!--
    <hr>
    <div id="ts-list" ng-if="showTsList">
        <div class="alert alert-info" role="alert" ng-if="sourceSeries.length > 0">
            Select the time series you would like replicated. Be sure to configure the Units.
        </div>

        <table class="table table-hover">
            <colgroup>
                <col class="col-md-1">
                <col class="col-md-7">
                <col class="col-md-3">
            </colgroup>
            <thead>
            <tr>
                <th><span class="glyphicon glyphicon-remove" aria-hidden="true" ng-click="deselectAll()"></span></th>
                <th>Name</th>
                <th>Units</th>
            </tr>
            </thead>
            <tbody>
            <tr ng-repeat="ts in selected = ( sourceSeries | filter:{_link_selected:true } | orderBy: 'name' )" ng-class="{'success':ts._link_selected == true}">
                <td><span class="glyphicon glyphicon-remove" aria-hidden="true" ng-click="ts._link_selected = !ts._link_selected" ></span></td>
                <td>{{ts.name}}</td>
                <td>
                    <select ng-options="unit as unit.unitString for unit in availableUnits track by unit.unitString" ng-model="ts.units"></select>
                </td>
            </tr>
            </tbody>
        </table>
        <div class="col-md-5">
          <div class="input-group">
            <span class="input-group-btn">
              <button type="button" class="btn btn-default">
                <span class="glyphicon glyphicon-filter"></span>
              </button>
            </span>
            <input type="text" class="form-control" ng-model="query" type="text" placeholder="Filter by" autofocus />
            <span class="input-group-btn">
              <button type="button" class="btn btn-default">
                <span class="glyphicon glyphicon-remove"  ng-click="query=''"></span>
              </button>
              <button type="button" class="btn btn-default">
                <span class="glyphicon glyphicon-log-in" ng-click="addAll()"></span>
              </button>
            </span>
          </div>
        </div>

        <table class="table table-hover">
            <colgroup>
                <col class="col-md-8">
                <col class="col-md-3">
            </colgroup>
            <thead>
            <tr>
                <th>Name</th>
                <th>Units</th>
            </tr>
            </thead>
            <tbody>
            <tr ng-repeat="ts in filteredContent.series = (sourceSeries | filter:{name:query, _link_selected:false } | orderBy: 'name')" ng-class="{'success':ts._link_selected == true}">
                <td ng-click="ts._link_selected = !ts._link_selected">{{ts.name}}</td>
                <td>
                    <select ng-options="unit as unit.unitString for unit in availableUnits track by unit.unitString" ng-model="ts.units"></select>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
-->

</div>

</Layout>

<style>


</style>

<script>
	import { goto } from 'sapper/runtime.js';
	import Layout from './_components/Layout.html';
  import {sourceTypes,rtxTypes} from '../model/typeData.js';
	import $ from "jquery";
	import _ from 'underscore';

  const fetchOpts = {headers: {}, credentials: 'include'};

	const postOpts = {
		method: 'post',
		headers: {'Content-Type': 'application/json'},
		credentials: 'include'
	};

	export default {
		components: {
			Layout
		},
    data () {
      return {
        sourceTypes,rtxTypes,
      };
	  },
    oncreate () {
			console.log('created');
			$('[data-toggle="tooltip"]').tooltip()
			this.set({sourceType: this.get('config').source._class});

			this.sourceTypeObserver = this.observe('sourceType', t => {
				if (t == '') {
					t = Object.keys(sourceTypes)[0];
				}
        let config = this.get('config');
				config.source._class = t;
				// set default values so they are not null
				let thisSourceOpts = sourceTypes[this.get('config').source._class];
				for (let row of thisSourceOpts.inputRows) {
					if (config.source[row.key] == undefined) {
						config.source[row.key] = '';
						if (row.inputType == "select-driver") {
							config.source[row.key] = this.get('drivers')[0];
						}
						if (row.inputType == "select-zone") {
							config.source[row.key] = 'utc';
						}
					}

				}
				this.set({config});
			});

    },
		ondestroy() {
			this.sourceTypeObserver.cancel();
		},
    preload(req) {
			let { params, query } = req;
			let myFetchOpts = fetchOpts;
			// forward any cookies to preserve session information
			if (req.headers && req.headers.cookie) {
				myFetchOpts.headers.cookie = req.headers.cookie;
			}
			// fetch some important data for the render...
      return Promise
			.all([
				fetch('/api/sessionData',myFetchOpts).then(r=>r.json()),
				fetch('/api/units',myFetchOpts).then(r=>r.json()),
				fetch('/api/drivers',myFetchOpts).then(r=>r.json())
			])
			.then(([config,availableUnits,drivers]) => {
				return {config,availableUnits,drivers};
			});
    },
    computed: {
      inputRows: (config,sourceTypes) => {
        let rows = sourceTypes[config.source._class].inputRows;
        return rows;
      },
			selectedSeries: (availableSeries) => _.filter(availableSeries, s => s._link_selected),
    },
    methods: {
			popError(err) {
				alert(err.error);
			},
      connect(event) {
				event.preventDefault();
				let s = this.get('config').source;
				let myPostOpts = _.extend({body:JSON.stringify(s)},postOpts);
        fetch('/api/source',myPostOpts)
				.then(res=> {
					if (res.status != 200) {
						return res.json().then(j => Promise.reject(j));
					}
					else {
						this.refreshSeriesList();
					}
				})
				.catch(err => {
					this.popError(err);
				});
      },
			refreshSeriesList() {
				fetch('/api/series', fetchOpts)
				.then(res=>res.json())
				.then(availableSeries => {
					_.each(availableSeries, s => _.extend(s,{_link_selected:false}));
					this.set({availableSeries});
				});
			},
      saveAndNext() {
				let config = this.get('config');
				let opts = _.extend({body:JSON.stringify(config)},postOpts);
				fetch('/api/sessionData', opts).then( res => {
					return res.json();
				}).then( resj => {
					// if ok, then go to next step.
					goto('/destination');
				});
      }
    }
	};
</script>
