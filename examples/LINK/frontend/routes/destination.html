<:Head>
<title>Destination Definition</title>
</:Head>

<Layout page='destination'>
	<div class="alert alert-info" role="alert">
		Configure the connection to the destination database.
		<a href="#" class="badge badge-pill badge-info" on:click='saveAndNext(event)'>Save &gt;</a>
	</div>
	<div class="alert alert-info">
		Please ensure that your firewall settings will allow traffic over the selected protocol. If you do not manage the cloud database, then contact the cloud database manager for this information.
	</div>

	<!-- Destination -->
	<div id="destination-select">
		<div class="form-group pull-left">
			<nav class="nav nav-pills nav-justified">
				{{#each Object.keys(destinationTypes) as type}}
  			<a class="nav-link {{config.destination._class == type ? 'active' : ''}}" href="#" on:click='setDestinationType(event,type)'>{{rtxTypes[type]}}</a>
				{{/each}}
			</nav>
		</div>
		<form role="form" class='form-horizontal'>
			<table class="table">
				<tbody>
					{{#each viewInputRows as dict}}
					<tr>
						<th scope="row">{{dict.text}}</th>
						<td>
							<input type="text" class="form-control" placeholder="{{dict.placeholder}}" bind:value="config.destination[dict.key]" uib-tooltip="{{dict.helptext}}">
						</td>
					</tr>
					{{/each}}
				</tbody>
			</table>

			<div class="input-group">
				<button type="submit" class="btn btn-default" on:click='connect(event)'>Connect</button>
			</div>
		</form>
		<hr>
		{{#if connectionMessage}}
		<div class="row">
			<div class="col-md-8">
				<div class="alert alert-info" role="alert">
					{{connectionMessage}}
				</div>
			</div>
		</div>
		{{/if}}
	</div>



</Layout>

<script>
	import { goto } from 'sapper/runtime.js';
	import Layout from './_components/Layout.html';
	import _ from 'underscore';
	import {destinationTypes,rtxTypes} from './_model/typeData.js';
	const fetchOpts = {headers: {}, credentials: 'include'};
	const postOpts = {
		method: 'post',
		headers: {'Content-Type': 'application/json'},
		credentials: 'include'
	};


	export default {
		components: {
			Layout
		},
		data() {
			return {
				destinationType: 'none',
				destinationTypes,
				rtxTypes,
			};
		},
		preload(req) {
			let { params, query } = req;
			let myFetchOpts = fetchOpts;
			// forward any cookies to preserve session information
			if (req.headers && req.headers.cookie) {
				myFetchOpts.headers.cookie = req.headers.cookie;
			}
			// fetch some important data for the render...
      return fetch('/api/config',myFetchOpts)
			.then(r => r.json())
			.then(config => {
				return {config};
			});
    },
		oncreate() {
			this.set({destinationType: this.get('config').destination._class});

			this.destinationTypeObserver = this.observe('destinationType', t => {
				if (t == '') {
					t = Object.keys(destinationTypes)[0];
				}
        let config = this.get('config');
				config.destination._class = t;
				// set default values so they are not null
				let dt = this.get('destinationType');
				if (dt in destinationTypes) {
					let thisDestOpts = destinationTypes[t];
					for (let row of thisDestOpts.inputRows) {
						if (config.destination[row.key] == undefined) {
							config.destination[row.key] = '';
						}
					}
				}
				this.set({config});
			});
		},
		ondestroy() {
			this.destinationTypeObserver.cancel();
		},
		computed: {
			viewInputRows: (destinationType, config) => {
				if (!config || !config.destination || !(destinationType in destinationTypes)) {
					return [];
				}
				return destinationTypes[destinationType].inputRows;
			},
		},
		methods: {
			popError(err) {
				alert(err.error);
			},
			setDestinationType(event,type) {
				event.preventDefault();
				this.set({destinationType:type});
			},
			connect(event) {
				event.preventDefault();
				let d = this.get('config').destination;
				let myPostOpts = _.extend({body:JSON.stringify(d)},postOpts);
        fetch('/api/destination',myPostOpts)
				.then(res=> {
					if (res.ok) {
						this.set({connectionMessage: 'Connected'});
					}
					else {
						return res.json().then(j => Promise.reject(j));
					}
				})
				.catch(err => {
					this.popError(err);
				});
			},
			saveAndNext() {
				event.preventDefault();
				let config = this.get('config');
				let opts = _.extend({body:JSON.stringify(config)},postOpts);
				fetch('/api/config', opts).then( res => {
					if (res.ok) {
						goto('/options');
					}
					else {
						alert('an error occurred');
					}
				});
      }
		},
	};
</script>
